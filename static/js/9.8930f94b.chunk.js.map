{"version":3,"sources":["../node_modules/three/examples/jsm/postprocessing/Pass.js","../node_modules/three/examples/jsm/shaders/CopyShader.js","../node_modules/three/examples/jsm/postprocessing/RenderPass.js","../node_modules/three/examples/jsm/postprocessing/ShaderPass.js","../node_modules/three/examples/jsm/postprocessing/MaskPass.js","../node_modules/three/examples/jsm/postprocessing/EffectComposer.js","../node_modules/three/examples/jsm/shaders/LuminosityHighPassShader.js","../node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js","../node_modules/three/examples/jsm/shaders/HalftoneShader.js","../node_modules/three/examples/jsm/postprocessing/HalftonePass.js"],"names":["Pass","this","enabled","needsSwap","clear","renderToScreen","Object","assign","prototype","setSize","render","console","error","FullScreenQuad","camera","OrthographicCamera","geometry","PlaneBufferGeometry","material","_mesh","Mesh","defineProperty","get","set","value","dispose","renderer","CopyShader","uniforms","vertexShader","join","fragmentShader","RenderPass","scene","overrideMaterial","clearColor","clearAlpha","call","undefined","clearDepth","create","constructor","writeBuffer","readBuffer","oldClearColor","oldClearAlpha","oldOverrideMaterial","oldAutoClear","autoClear","getClearColor","getHex","getClearAlpha","setClearColor","setRenderTarget","autoClearColor","autoClearDepth","autoClearStencil","ShaderPass","shader","textureID","ShaderMaterial","UniformsUtils","clone","defines","fsQuad","texture","MaskPass","inverse","writeValue","clearValue","context","getContext","state","buffers","color","setMask","depth","setLocked","stencil","setTest","setOp","REPLACE","setFunc","ALWAYS","setClear","EQUAL","KEEP","ClearMaskPass","EffectComposer","renderTarget","parameters","minFilter","LinearFilter","magFilter","format","RGBAFormat","stencilBuffer","size","getSize","Vector2","_pixelRatio","getPixelRatio","_width","width","_height","height","WebGLRenderTarget","name","renderTarget1","renderTarget2","passes","copyPass","clock","Clock","swapBuffers","tmp","addPass","pass","push","insertPass","index","splice","isLastEnabledPass","passIndex","i","length","deltaTime","getDelta","currentRenderTarget","getRenderTarget","maskActive","il","NOTEQUAL","reset","effectiveWidth","effectiveHeight","setPixelRatio","pixelRatio","LuminosityHighPassShader","shaderID","Color","UnrealBloomPass","resolution","strength","radius","threshold","x","y","pars","renderTargetsHorizontal","renderTargetsVertical","nMips","resx","Math","round","resy","renderTargetBright","generateMipmaps","renderTargetHorizonal","renderTargetVertical","highPassShader","highPassUniforms","materialHighPassFilter","separableBlurMaterials","kernelSizeArray","getSeperableBlurMaterial","compositeMaterial","getCompositeMaterial","needsUpdate","bloomTintColors","Vector3","copyShader","copyUniforms","materialCopy","blending","AdditiveBlending","depthTest","depthWrite","transparent","basic","MeshBasicMaterial","copy","map","inputRenderTarget","BlurDirectionX","BlurDirectionY","kernelRadius","HalftoneShader","PI","HalftonePass","params","key","hasOwnProperty"],"mappings":"yIAAA,8CAMA,SAASA,IAGRC,KAAKC,SAAU,EAGfD,KAAKE,WAAY,EAGjBF,KAAKG,OAAQ,EAGbH,KAAKI,gBAAiB,EAIvBC,OAAOC,OAAQP,EAAKQ,UAAW,CAE9BC,QAAS,aAETC,OAAQ,WAEPC,QAAQC,MAAO,iEAQjBZ,EAAKa,eAAmB,WAEvB,IAAIC,EAAS,IAAIC,sBAAsB,EAAG,EAAG,GAAK,EAAG,EAAG,GACpDC,EAAW,IAAIC,sBAAqB,EAAG,GAEvCJ,EAAiB,SAAWK,GAE/BjB,KAAKkB,MAAQ,IAAIC,OAAMJ,EAAUE,IAoClC,OAhCAZ,OAAOe,eAAgBR,EAAeL,UAAW,WAAY,CAE5Dc,IAAK,WAEJ,OAAOrB,KAAKkB,MAAMD,UAInBK,IAAK,SAAWC,GAEfvB,KAAKkB,MAAMD,SAAWM,KAMxBlB,OAAOC,OAAQM,EAAeL,UAAW,CAExCiB,QAAS,WAERxB,KAAKkB,MAAMH,SAASS,WAIrBf,OAAQ,SAAWgB,GAElBA,EAAShB,OAAQT,KAAKkB,MAAOL,MAMxBD,EA3CgB,I,gCCpCxB,kCAQA,IAAIc,EAAa,CAEhBC,SAAU,CAET,SAAY,CAAEJ,MAAO,MACrB,QAAW,CAAEA,MAAO,IAIrBK,aAAc,CAEb,oBAEA,gBAEA,cACA,8EAEA,KAECC,KAAM,MAERC,eAAgB,CAEf,yBAEA,8BAEA,oBAEA,gBAEA,6CACA,oCAEA,KAECD,KAAM,Q,gCC7CT,8CAOIE,EAAa,SAAWC,EAAOnB,EAAQoB,EAAkBC,EAAYC,GAExEpC,IAAKqC,KAAMpC,MAEXA,KAAKgC,MAAQA,EACbhC,KAAKa,OAASA,EAEdb,KAAKiC,iBAAmBA,EAExBjC,KAAKkC,WAAaA,EAClBlC,KAAKmC,gBAA8BE,IAAfF,EAA6BA,EAAa,EAE9DnC,KAAKG,OAAQ,EACbH,KAAKsC,YAAa,EAClBtC,KAAKE,WAAY,GAIlB6B,EAAWxB,UAAYF,OAAOC,OAAQD,OAAOkC,OAAQxC,IAAKQ,WAAa,CAEtEiC,YAAaT,EAEbtB,OAAQ,SAAWgB,EAAUgB,EAAaC,GAEzC,IAGIC,EAAeC,EAAeC,EAH9BC,EAAerB,EAASsB,UAC5BtB,EAASsB,WAAY,OAIUV,IAA1BrC,KAAKiC,mBAETY,EAAsB7C,KAAKgC,MAAMC,iBAEjCjC,KAAKgC,MAAMC,iBAAmBjC,KAAKiC,kBAI/BjC,KAAKkC,aAETS,EAAgBlB,EAASuB,gBAAgBC,SACzCL,EAAgBnB,EAASyB,gBAEzBzB,EAAS0B,cAAenD,KAAKkC,WAAYlC,KAAKmC,aAI1CnC,KAAKsC,YAETb,EAASa,aAIVb,EAAS2B,gBAAiBpD,KAAKI,eAAiB,KAAOsC,GAGlD1C,KAAKG,OAAQsB,EAAStB,MAAOsB,EAAS4B,eAAgB5B,EAAS6B,eAAgB7B,EAAS8B,kBAC7F9B,EAAShB,OAAQT,KAAKgC,MAAOhC,KAAKa,QAE7Bb,KAAKkC,YAETT,EAAS0B,cAAeR,EAAeC,QAITP,IAA1BrC,KAAKiC,mBAETjC,KAAKgC,MAAMC,iBAAmBY,GAI/BpB,EAASsB,UAAYD,M,8FCnEnBU,EAAa,SAAWC,EAAQC,GAEnC3D,IAAKqC,KAAMpC,MAEXA,KAAK0D,eAA4BrB,IAAdqB,EAA4BA,EAAY,WAEtDD,aAAkBE,kBAEtB3D,KAAK2B,SAAW8B,EAAO9B,SAEvB3B,KAAKiB,SAAWwC,GAELA,IAEXzD,KAAK2B,SAAWiC,gBAAcC,MAAOJ,EAAO9B,UAE5C3B,KAAKiB,SAAW,IAAI0C,iBAAgB,CAEnCG,QAASzD,OAAOC,OAAQ,GAAImD,EAAOK,SACnCnC,SAAU3B,KAAK2B,SACfC,aAAc6B,EAAO7B,aACrBE,eAAgB2B,EAAO3B,kBAMzB9B,KAAK+D,OAAS,IAAIhE,IAAKa,eAAgBZ,KAAKiB,WAI7CuC,EAAWjD,UAAYF,OAAOC,OAAQD,OAAOkC,OAAQxC,IAAKQ,WAAa,CAEtEiC,YAAagB,EAEb/C,OAAQ,SAAWgB,EAAUgB,EAAaC,GAEpC1C,KAAK2B,SAAU3B,KAAK0D,aAExB1D,KAAK2B,SAAU3B,KAAK0D,WAAYnC,MAAQmB,EAAWsB,SAIpDhE,KAAK+D,OAAO9C,SAAWjB,KAAKiB,SAEvBjB,KAAKI,gBAETqB,EAAS2B,gBAAiB,MAC1BpD,KAAK+D,OAAOtD,OAAQgB,KAIpBA,EAAS2B,gBAAiBX,GAErBzC,KAAKG,OAAQsB,EAAStB,MAAOsB,EAAS4B,eAAgB5B,EAAS6B,eAAgB7B,EAAS8B,kBAC7FvD,KAAK+D,OAAOtD,OAAQgB,OC1DvB,IAAIwC,EAAW,SAAWjC,EAAOnB,GAEhCd,IAAKqC,KAAMpC,MAEXA,KAAKgC,MAAQA,EACbhC,KAAKa,OAASA,EAEdb,KAAKG,OAAQ,EACbH,KAAKE,WAAY,EAEjBF,KAAKkE,SAAU,GAIhBD,EAAS1D,UAAYF,OAAOC,OAAQD,OAAOkC,OAAQxC,IAAKQ,WAAa,CAEpEiC,YAAayB,EAEbxD,OAAQ,SAAWgB,EAAUgB,EAAaC,GAEzC,IAeIyB,EAAYC,EAfZC,EAAU5C,EAAS6C,aACnBC,EAAQ9C,EAAS8C,MAIrBA,EAAMC,QAAQC,MAAMC,SAAS,GAC7BH,EAAMC,QAAQG,MAAMD,SAAS,GAI7BH,EAAMC,QAAQC,MAAMG,WAAW,GAC/BL,EAAMC,QAAQG,MAAMC,WAAW,GAM1B5E,KAAKkE,SAETC,EAAa,EACbC,EAAa,IAIbD,EAAa,EACbC,EAAa,GAIdG,EAAMC,QAAQK,QAAQC,SAAS,GAC/BP,EAAMC,QAAQK,QAAQE,MAAOV,EAAQW,QAASX,EAAQW,QAASX,EAAQW,SACvET,EAAMC,QAAQK,QAAQI,QAASZ,EAAQa,OAAQf,EAAY,YAC3DI,EAAMC,QAAQK,QAAQM,SAAUf,GAChCG,EAAMC,QAAQK,QAAQD,WAAW,GAIjCnD,EAAS2B,gBAAiBV,GACrB1C,KAAKG,OAAQsB,EAAStB,QAC3BsB,EAAShB,OAAQT,KAAKgC,MAAOhC,KAAKa,QAElCY,EAAS2B,gBAAiBX,GACrBzC,KAAKG,OAAQsB,EAAStB,QAC3BsB,EAAShB,OAAQT,KAAKgC,MAAOhC,KAAKa,QAIlC0D,EAAMC,QAAQC,MAAMG,WAAW,GAC/BL,EAAMC,QAAQG,MAAMC,WAAW,GAI/BL,EAAMC,QAAQK,QAAQD,WAAW,GACjCL,EAAMC,QAAQK,QAAQI,QAASZ,EAAQe,MAAO,EAAG,YACjDb,EAAMC,QAAQK,QAAQE,MAAOV,EAAQgB,KAAMhB,EAAQgB,KAAMhB,EAAQgB,MACjEd,EAAMC,QAAQK,QAAQD,WAAW,MAOnC,IAAIU,EAAgB,WAEnBvF,IAAKqC,KAAMpC,MAEXA,KAAKE,WAAY,GAIlBoF,EAAc/E,UAAYF,OAAOkC,OAAQxC,IAAKQ,WAE9CF,OAAOC,OAAQgF,EAAc/E,UAAW,CAEvCE,OAAQ,SAAWgB,GAElBA,EAAS8C,MAAMC,QAAQK,QAAQD,WAAW,GAC1CnD,EAAS8C,MAAMC,QAAQK,QAAQC,SAAS,MCrF1C,IAAIS,EAAiB,SAAW9D,EAAU+D,GAIzC,GAFAxF,KAAKyB,SAAWA,OAEMY,IAAjBmD,EAA6B,CAEjC,IAAIC,EAAa,CAChBC,UAAWC,eACXC,UAAWD,eACXE,OAAQC,aACRC,eAAe,GAGZC,EAAOvE,EAASwE,QAAS,IAAIC,WACjClG,KAAKmG,YAAc1E,EAAS2E,gBAC5BpG,KAAKqG,OAASL,EAAKM,MACnBtG,KAAKuG,QAAUP,EAAKQ,QAEpBhB,EAAe,IAAIiB,oBAAmBzG,KAAKqG,OAASrG,KAAKmG,YAAanG,KAAKuG,QAAUvG,KAAKmG,YAAaV,IAC1FzB,QAAQ0C,KAAO,0BAI5B1G,KAAKmG,YAAc,EACnBnG,KAAKqG,OAASb,EAAac,MAC3BtG,KAAKuG,QAAUf,EAAagB,OAI7BxG,KAAK2G,cAAgBnB,EACrBxF,KAAK4G,cAAgBpB,EAAa3B,QAClC7D,KAAK4G,cAAc5C,QAAQ0C,KAAO,qBAElC1G,KAAKyC,YAAczC,KAAK2G,cACxB3G,KAAK0C,WAAa1C,KAAK4G,cAEvB5G,KAAKI,gBAAiB,EAEtBJ,KAAK6G,OAAS,QAIMxE,IAAfX,KAEJhB,QAAQC,MAAO,kDAII0B,IAAfmB,GAEJ9C,QAAQC,MAAO,6CAIhBX,KAAK8G,SAAW,IAAItD,EAAY9B,KAEhC1B,KAAK+G,MAAQ,IAAIC,SAIlB3G,OAAOC,OAAQiF,EAAehF,UAAW,CAExC0G,YAAa,WAEZ,IAAIC,EAAMlH,KAAK0C,WACf1C,KAAK0C,WAAa1C,KAAKyC,YACvBzC,KAAKyC,YAAcyE,GAIpBC,QAAS,SAAWC,GAEnBpH,KAAK6G,OAAOQ,KAAMD,GAClBA,EAAK5G,QAASR,KAAKqG,OAASrG,KAAKmG,YAAanG,KAAKuG,QAAUvG,KAAKmG,cAInEmB,WAAY,SAAWF,EAAMG,GAE5BvH,KAAK6G,OAAOW,OAAQD,EAAO,EAAGH,IAI/BK,kBAAmB,SAAWC,GAE7B,IAAM,IAAIC,EAAID,EAAY,EAAGC,EAAI3H,KAAK6G,OAAOe,OAAQD,IAEpD,GAAK3H,KAAK6G,OAAQc,GAAI1H,QAErB,OAAO,EAMT,OAAO,GAIRQ,OAAQ,SAAWoH,QAICxF,IAAdwF,IAEJA,EAAY7H,KAAK+G,MAAMe,YAIxB,IAIIV,EAAMO,EAJNI,EAAsB/H,KAAKyB,SAASuG,kBAEpCC,GAAa,EAEJC,EAAKlI,KAAK6G,OAAOe,OAE9B,IAAMD,EAAI,EAAGA,EAAIO,EAAIP,IAIpB,IAAsB,KAFtBP,EAAOpH,KAAK6G,OAAQc,IAEV1H,QAAV,CAKA,GAHAmH,EAAKhH,eAAmBJ,KAAKI,gBAAkBJ,KAAKyH,kBAAmBE,GACvEP,EAAK3G,OAAQT,KAAKyB,SAAUzB,KAAKyC,YAAazC,KAAK0C,WAAYmF,EAAWI,GAErEb,EAAKlH,UAAY,CAErB,GAAK+H,EAAa,CAEjB,IAAI5D,EAAUrE,KAAKyB,SAAS6C,aACxBO,EAAU7E,KAAKyB,SAAS8C,MAAMC,QAAQK,QAG1CA,EAAQI,QAASZ,EAAQ8D,SAAU,EAAG,YAEtCnI,KAAK8G,SAASrG,OAAQT,KAAKyB,SAAUzB,KAAKyC,YAAazC,KAAK0C,WAAYmF,GAGxEhD,EAAQI,QAASZ,EAAQe,MAAO,EAAG,YAIpCpF,KAAKiH,mBAIY5E,IAAb4B,IAECmD,aAAgBnD,EAEpBgE,GAAa,EAEFb,aAAgB9B,IAE3B2C,GAAa,IAQhBjI,KAAKyB,SAAS2B,gBAAiB2E,IAIhCK,MAAO,SAAW5C,GAEjB,QAAsBnD,IAAjBmD,EAA6B,CAEjC,IAAIQ,EAAOhG,KAAKyB,SAASwE,QAAS,IAAIC,WACtClG,KAAKmG,YAAcnG,KAAKyB,SAAS2E,gBACjCpG,KAAKqG,OAASL,EAAKM,MACnBtG,KAAKuG,QAAUP,EAAKQ,QAEpBhB,EAAexF,KAAK2G,cAAc9C,SACrBrD,QAASR,KAAKqG,OAASrG,KAAKmG,YAAanG,KAAKuG,QAAUvG,KAAKmG,aAI3EnG,KAAK2G,cAAcnF,UACnBxB,KAAK4G,cAAcpF,UACnBxB,KAAK2G,cAAgBnB,EACrBxF,KAAK4G,cAAgBpB,EAAa3B,QAElC7D,KAAKyC,YAAczC,KAAK2G,cACxB3G,KAAK0C,WAAa1C,KAAK4G,eAIxBpG,QAAS,SAAW8F,EAAOE,GAE1BxG,KAAKqG,OAASC,EACdtG,KAAKuG,QAAUC,EAEf,IAAI6B,EAAiBrI,KAAKqG,OAASrG,KAAKmG,YACpCmC,EAAkBtI,KAAKuG,QAAUvG,KAAKmG,YAE1CnG,KAAK2G,cAAcnG,QAAS6H,EAAgBC,GAC5CtI,KAAK4G,cAAcpG,QAAS6H,EAAgBC,GAE5C,IAAM,IAAIX,EAAI,EAAGA,EAAI3H,KAAK6G,OAAOe,OAAQD,IAExC3H,KAAK6G,OAAQc,GAAInH,QAAS6H,EAAgBC,IAM5CC,cAAe,SAAWC,GAEzBxI,KAAKmG,YAAcqC,EAEnBxI,KAAKQ,QAASR,KAAKqG,OAAQrG,KAAKuG,YAOlC,IAAIxG,EAAO,WAGVC,KAAKC,SAAU,EAGfD,KAAKE,WAAY,EAGjBF,KAAKG,OAAQ,EAGbH,KAAKI,gBAAiB,GAIvBC,OAAOC,OAAQP,EAAKQ,UAAW,CAE9BC,QAAS,aAETC,OAAQ,WAEPC,QAAQC,MAAO,iEAOjBZ,EAAKa,eAAmB,WAEvB,IAAIC,EAAS,IAAIC,sBAAsB,EAAG,EAAG,GAAK,EAAG,EAAG,GACpDC,EAAW,IAAIC,sBAAqB,EAAG,GAEvCJ,EAAiB,SAAWK,GAE/BjB,KAAKkB,MAAQ,IAAIC,OAAMJ,EAAUE,IAoClC,OAhCAZ,OAAOe,eAAgBR,EAAeL,UAAW,WAAY,CAE5Dc,IAAK,WAEJ,OAAOrB,KAAKkB,MAAMD,UAInBK,IAAK,SAAWC,GAEfvB,KAAKkB,MAAMD,SAAWM,KAMxBlB,OAAOC,OAAQM,EAAeL,UAAW,CAExCiB,QAAS,WAERxB,KAAKkB,MAAMH,SAASS,WAIrBf,OAAQ,SAAWgB,GAElBA,EAAShB,OAAQT,KAAKkB,MAAOL,MAMxBD,EA3CgB,I,8FChQpB6H,EAA2B,CAE9BC,SAAU,qBAEV/G,SAAU,CAET,SAAY,CAAEJ,MAAO,MACrB,oBAAuB,CAAEA,MAAO,GAChC,YAAe,CAAEA,MAAO,GACxB,aAAgB,CAAEA,MAAO,IAAIoH,QAAO,IACpC,eAAkB,CAAEpH,MAAO,IAI5BK,aAAc,CAEb,oBAEA,gBAEA,cAEA,8EAEA,KAECC,KAAM,MAERC,eAAgB,CAEf,8BACA,6BACA,gCACA,qCACA,6BAEA,oBAEA,gBAEA,6CAEA,6CAEA,sCAEA,iEAEA,2FAEA,qDAEA,KAECD,KAAM,OCpCL+G,EAAkB,SAAWC,EAAYC,EAAUC,EAAQC,GAE9DjJ,IAAKqC,KAAMpC,MAEXA,KAAK8I,cAA0BzG,IAAbyG,EAA2BA,EAAW,EACxD9I,KAAK+I,OAASA,EACd/I,KAAKgJ,UAAYA,EACjBhJ,KAAK6I,gBAA8BxG,IAAfwG,EAA6B,IAAI3C,UAAS2C,EAAWI,EAAGJ,EAAWK,GAAM,IAAIhD,UAAS,IAAK,KAG/GlG,KAAKkC,WAAa,IAAIyG,QAAO,EAAG,EAAG,GAGnC,IAAIQ,EAAO,CAAEzD,UAAWC,eAAcC,UAAWD,eAAcE,OAAQC,cACvE9F,KAAKoJ,wBAA0B,GAC/BpJ,KAAKqJ,sBAAwB,GAC7BrJ,KAAKsJ,MAAQ,EACb,IAAIC,EAAOC,KAAKC,MAAOzJ,KAAK6I,WAAWI,EAAI,GACvCS,EAAOF,KAAKC,MAAOzJ,KAAK6I,WAAWK,EAAI,GAE3ClJ,KAAK2J,mBAAqB,IAAIlD,oBAAmB8C,EAAMG,EAAMP,GAC7DnJ,KAAK2J,mBAAmB3F,QAAQ0C,KAAO,yBACvC1G,KAAK2J,mBAAmB3F,QAAQ4F,iBAAkB,EAElD,IAAM,IAAIjC,EAAI,EAAGA,EAAI3H,KAAKsJ,MAAO3B,IAAO,CAEvC,IAAIkC,EAAwB,IAAIpD,oBAAmB8C,EAAMG,EAAMP,GAE/DU,EAAsB7F,QAAQ0C,KAAO,oBAAsBiB,EAC3DkC,EAAsB7F,QAAQ4F,iBAAkB,EAEhD5J,KAAKoJ,wBAAwB/B,KAAMwC,GAEnC,IAAIC,EAAuB,IAAIrD,oBAAmB8C,EAAMG,EAAMP,GAE9DW,EAAqB9F,QAAQ0C,KAAO,oBAAsBiB,EAC1DmC,EAAqB9F,QAAQ4F,iBAAkB,EAE/C5J,KAAKqJ,sBAAsBhC,KAAMyC,GAEjCP,EAAOC,KAAKC,MAAOF,EAAO,GAE1BG,EAAOF,KAAKC,MAAOC,EAAO,QAMOrH,IAA7BoG,GACJ/H,QAAQC,MAAO,sDAEhB,IAAIoJ,EAAiBtB,EACrBzI,KAAKgK,iBAAmBpG,gBAAcC,MAAOkG,EAAepI,UAE5D3B,KAAKgK,iBAAL,oBAA+CzI,MAAQyH,EACvDhJ,KAAKgK,iBAAL,YAAuCzI,MAAQ,IAE/CvB,KAAKiK,uBAAyB,IAAItG,iBAAgB,CACjDhC,SAAU3B,KAAKgK,iBACfpI,aAAcmI,EAAenI,aAC7BE,eAAgBiI,EAAejI,eAC/BgC,QAAS,KAIV9D,KAAKkK,uBAAyB,GAC9B,IAAIC,EAAkB,CAAE,EAAG,EAAG,EAAG,EAAG,IAIpC,IAHIZ,EAAOC,KAAKC,MAAOzJ,KAAK6I,WAAWI,EAAI,GACvCS,EAAOF,KAAKC,MAAOzJ,KAAK6I,WAAWK,EAAI,GAEjCvB,EAAI,EAAGA,EAAI3H,KAAKsJ,MAAO3B,IAEhC3H,KAAKkK,uBAAuB7C,KAAMrH,KAAKoK,yBAA0BD,EAAiBxC,KAElF3H,KAAKkK,uBAAwBvC,GAAIhG,SAAjC,QAAuDJ,MAAQ,IAAI2E,UAASqD,EAAMG,GAElFH,EAAOC,KAAKC,MAAOF,EAAO,GAE1BG,EAAOF,KAAKC,MAAOC,EAAO,GAK3B1J,KAAKqK,kBAAoBrK,KAAKsK,qBAAsBtK,KAAKsJ,OACzDtJ,KAAKqK,kBAAkB1I,SAAvB,aAAkDJ,MAAQvB,KAAKqJ,sBAAuB,GAAIrF,QAC1FhE,KAAKqK,kBAAkB1I,SAAvB,aAAkDJ,MAAQvB,KAAKqJ,sBAAuB,GAAIrF,QAC1FhE,KAAKqK,kBAAkB1I,SAAvB,aAAkDJ,MAAQvB,KAAKqJ,sBAAuB,GAAIrF,QAC1FhE,KAAKqK,kBAAkB1I,SAAvB,aAAkDJ,MAAQvB,KAAKqJ,sBAAuB,GAAIrF,QAC1FhE,KAAKqK,kBAAkB1I,SAAvB,aAAkDJ,MAAQvB,KAAKqJ,sBAAuB,GAAIrF,QAC1FhE,KAAKqK,kBAAkB1I,SAAvB,cAAmDJ,MAAQuH,EAC3D9I,KAAKqK,kBAAkB1I,SAAvB,YAAiDJ,MAAQ,GACzDvB,KAAKqK,kBAAkBE,aAAc,EAGrCvK,KAAKqK,kBAAkB1I,SAAvB,aAAkDJ,MAD/B,CAAE,EAAK,GAAK,GAAK,GAAK,IAEzCvB,KAAKwK,gBAAkB,CAAE,IAAIC,UAAS,EAAG,EAAG,GAAK,IAAIA,UAAS,EAAG,EAAG,GAAK,IAAIA,UAAS,EAAG,EAAG,GACrF,IAAIA,UAAS,EAAG,EAAG,GAAK,IAAIA,UAAS,EAAG,EAAG,IAClDzK,KAAKqK,kBAAkB1I,SAAvB,gBAAqDJ,MAAQvB,KAAKwK,qBAG9CnI,IAAfX,KAEJhB,QAAQC,MAAO,wCAIhB,IAAI+J,EAAahJ,IAEjB1B,KAAK2K,aAAe/G,gBAAcC,MAAO6G,EAAW/I,UACpD3B,KAAK2K,aAAL,QAA+BpJ,MAAQ,EAEvCvB,KAAK4K,aAAe,IAAIjH,iBAAgB,CACvChC,SAAU3B,KAAK2K,aACf/I,aAAc8I,EAAW9I,aACzBE,eAAgB4I,EAAW5I,eAC3B+I,SAAUC,mBACVC,WAAW,EACXC,YAAY,EACZC,aAAa,IAGdjL,KAAKC,SAAU,EACfD,KAAKE,WAAY,EAEjBF,KAAK2C,cAAgB,IAAIgG,QACzB3I,KAAK4C,cAAgB,EAErB5C,KAAKkL,MAAQ,IAAIC,oBAEjBnL,KAAK+D,OAAS,IAAIhE,IAAKa,eAAgB,OAIxCgI,EAAgBrI,UAAYF,OAAOC,OAAQD,OAAOkC,OAAQxC,IAAKQ,WAAa,CAE3EiC,YAAaoG,EAEbpH,QAAS,WAER,IAAM,IAAImG,EAAI,EAAGA,EAAI3H,KAAKoJ,wBAAwBxB,OAAQD,IAEzD3H,KAAKoJ,wBAAyBzB,GAAInG,UAInC,IAAUmG,EAAI,EAAGA,EAAI3H,KAAKqJ,sBAAsBzB,OAAQD,IAEvD3H,KAAKqJ,sBAAuB1B,GAAInG,UAIjCxB,KAAK2J,mBAAmBnI,WAIzBhB,QAAS,SAAW8F,EAAOE,GAE1B,IAAI+C,EAAOC,KAAKC,MAAOnD,EAAQ,GAC3BoD,EAAOF,KAAKC,MAAOjD,EAAS,GAEhCxG,KAAK2J,mBAAmBnJ,QAAS+I,EAAMG,GAEvC,IAAM,IAAI/B,EAAI,EAAGA,EAAI3H,KAAKsJ,MAAO3B,IAEhC3H,KAAKoJ,wBAAyBzB,GAAInH,QAAS+I,EAAMG,GACjD1J,KAAKqJ,sBAAuB1B,GAAInH,QAAS+I,EAAMG,GAE/C1J,KAAKkK,uBAAwBvC,GAAIhG,SAAjC,QAAuDJ,MAAQ,IAAI2E,UAASqD,EAAMG,GAElFH,EAAOC,KAAKC,MAAOF,EAAO,GAC1BG,EAAOF,KAAKC,MAAOC,EAAO,IAM5BjJ,OAAQ,SAAWgB,EAAUgB,EAAaC,EAAYmF,EAAWI,GAEhEjI,KAAK2C,cAAcyI,KAAM3J,EAASuB,iBAClChD,KAAK4C,cAAgBnB,EAASyB,gBAC9B,IAAIJ,EAAerB,EAASsB,UAC5BtB,EAASsB,WAAY,EAErBtB,EAAS0B,cAAenD,KAAKkC,WAAY,GAEpC+F,GAAaxG,EAAS8C,MAAMC,QAAQK,QAAQC,SAAS,GAIrD9E,KAAKI,iBAETJ,KAAK+D,OAAO9C,SAAWjB,KAAKkL,MAC5BlL,KAAKkL,MAAMG,IAAM3I,EAAWsB,QAE5BvC,EAAS2B,gBAAiB,MAC1B3B,EAAStB,QACTH,KAAK+D,OAAOtD,OAAQgB,IAMrBzB,KAAKgK,iBAAL,SAAoCzI,MAAQmB,EAAWsB,QACvDhE,KAAKgK,iBAAL,oBAA+CzI,MAAQvB,KAAKgJ,UAC5DhJ,KAAK+D,OAAO9C,SAAWjB,KAAKiK,uBAE5BxI,EAAS2B,gBAAiBpD,KAAK2J,oBAC/BlI,EAAStB,QACTH,KAAK+D,OAAOtD,OAAQgB,GAMpB,IAFA,IAAI6J,EAAoBtL,KAAK2J,mBAEnBhC,EAAI,EAAGA,EAAI3H,KAAKsJ,MAAO3B,IAEhC3H,KAAK+D,OAAO9C,SAAWjB,KAAKkK,uBAAwBvC,GAEpD3H,KAAKkK,uBAAwBvC,GAAIhG,SAAjC,aAA4DJ,MAAQ+J,EAAkBtH,QACtFhE,KAAKkK,uBAAwBvC,GAAIhG,SAAjC,UAAyDJ,MAAQqH,EAAgB2C,eACjF9J,EAAS2B,gBAAiBpD,KAAKoJ,wBAAyBzB,IACxDlG,EAAStB,QACTH,KAAK+D,OAAOtD,OAAQgB,GAEpBzB,KAAKkK,uBAAwBvC,GAAIhG,SAAjC,aAA4DJ,MAAQvB,KAAKoJ,wBAAyBzB,GAAI3D,QACtGhE,KAAKkK,uBAAwBvC,GAAIhG,SAAjC,UAAyDJ,MAAQqH,EAAgB4C,eACjF/J,EAAS2B,gBAAiBpD,KAAKqJ,sBAAuB1B,IACtDlG,EAAStB,QACTH,KAAK+D,OAAOtD,OAAQgB,GAEpB6J,EAAoBtL,KAAKqJ,sBAAuB1B,GAMjD3H,KAAK+D,OAAO9C,SAAWjB,KAAKqK,kBAC5BrK,KAAKqK,kBAAkB1I,SAAvB,cAAmDJ,MAAQvB,KAAK8I,SAChE9I,KAAKqK,kBAAkB1I,SAAvB,YAAiDJ,MAAQvB,KAAK+I,OAC9D/I,KAAKqK,kBAAkB1I,SAAvB,gBAAqDJ,MAAQvB,KAAKwK,gBAElE/I,EAAS2B,gBAAiBpD,KAAKoJ,wBAAyB,IACxD3H,EAAStB,QACTH,KAAK+D,OAAOtD,OAAQgB,GAIpBzB,KAAK+D,OAAO9C,SAAWjB,KAAK4K,aAC5B5K,KAAK2K,aAAL,SAAgCpJ,MAAQvB,KAAKoJ,wBAAyB,GAAIpF,QAErEiE,GAAaxG,EAAS8C,MAAMC,QAAQK,QAAQC,SAAS,GAErD9E,KAAKI,gBAETqB,EAAS2B,gBAAiB,MAC1BpD,KAAK+D,OAAOtD,OAAQgB,KAIpBA,EAAS2B,gBAAiBV,GAC1B1C,KAAK+D,OAAOtD,OAAQgB,IAMrBA,EAAS0B,cAAenD,KAAK2C,cAAe3C,KAAK4C,eACjDnB,EAASsB,UAAYD,GAItBsH,yBAA0B,SAAWqB,GAEpC,OAAO,IAAI9H,iBAAgB,CAE1BG,QAAS,CACR,cAAiB2H,EACjB,MAASA,GAGV9J,SAAU,CACT,aAAgB,CAAEJ,MAAO,MACzB,QAAW,CAAEA,MAAO,IAAI2E,UAAS,GAAK,KACtC,UAAa,CAAE3E,MAAO,IAAI2E,UAAS,GAAK,MAGzCtE,aACC,gKAMDE,eACC,8+BA6BHwI,qBAAsB,SAAWhB,GAEhC,OAAO,IAAI3F,iBAAgB,CAE1BG,QAAS,CACR,SAAYwF,GAGb3H,SAAU,CACT,aAAgB,CAAEJ,MAAO,MACzB,aAAgB,CAAEA,MAAO,MACzB,aAAgB,CAAEA,MAAO,MACzB,aAAgB,CAAEA,MAAO,MACzB,aAAgB,CAAEA,MAAO,MACzB,YAAe,CAAEA,MAAO,MACxB,cAAiB,CAAEA,MAAO,GAC1B,aAAgB,CAAEA,MAAO,MACzB,gBAAmB,CAAEA,MAAO,MAC5B,YAAe,CAAEA,MAAO,IAGzBK,aACC,gKAMDE,eACC,uvCA8BJ8G,EAAgB2C,eAAiB,IAAIrF,UAAS,EAAK,GACnD0C,EAAgB4C,eAAiB,IAAItF,UAAS,EAAK,I,sFCjZ/CwF,EAAiB,CAEpB/J,SAAU,CACT,SAAY,CAAEJ,MAAO,MACrB,MAAS,CAAEA,MAAO,GAClB,OAAU,CAAEA,MAAO,GACnB,QAAW,CAAEA,MAAOiI,KAAKmC,GAAK,GAAK,GACnC,QAAW,CAAEpK,MAAOiI,KAAKmC,GAAK,GAAK,GACnC,QAAW,CAAEpK,MAAOiI,KAAKmC,GAAK,GAAK,GACnC,QAAW,CAAEpK,MAAO,GACpB,MAAS,CAAEA,MAAO,GAClB,OAAU,CAAEA,MAAO,GACnB,SAAY,CAAEA,MAAO,GACrB,aAAgB,CAAEA,MAAO,GACzB,UAAa,CAAEA,OAAO,GACtB,QAAW,CAAEA,OAAO,IAGrBK,aAAc,CAEb,oBAEA,gBAEA,cACA,4EAEA,KAECC,KAAM,MAERC,eAAgB,CAEf,qCACA,0CACA,yBACA,sBACA,0BACA,uBACA,yBACA,4BACA,8BACA,yBACA,6BACA,4BACA,8BACA,wBACA,yBACA,yBACA,yBACA,yBACA,uBACA,wBACA,qBACA,wBACA,0BACA,4BACA,oBACA,0BACA,yBAEA,6CAGA,oCAEA,IAEA,oCAGA,kCAEA,IAEA,2BAGG,+EAEH,IAEA,4GAGA,wDACA,yBAEA,gCAEA,gDAEA,2CAEA,gDAEA,2BACA,wGACA,2FACA,QAEA,wCAEA,6CACA,iFACA,0DAEA,0CAEA,kEACA,yCACA,yCACA,oCACA,+FAEA,MAEA,uBAEA,IAEA,gBAGA,iBACA,aACA,aACA,aACA,aACA,iBACA,iBACA,iBACA,iBAEA,KAEA,iCAGA,iFACA,2EACA,yCACA,gCAEA,0CAEA,0CACA,qEACA,+EAEA,MAEA,mCACA,gBAEA,IAEA,6EAGA,uDAEA,0BAEA,qCACA,qCACA,qCACA,qCAEA,+BAEA,qCACA,qCACA,qCACA,qCAEA,aAEA,qCACA,qCACA,qCACA,qCAEA,MAEA,iFACA,iFACA,iFACA,iFACA,uEACA,wEACA,wEACA,wEACA,kCAEA,gBAEA,IAEA,+EAGA,YAGA,2DACA,kCACA,4EACA,2EACA,8DACA,oEACA,0DACA,iHACA,4GACA,sDACA,uGAGA,kBACA,0DACA,0DAGA,4BAEA,iDACA,gFACA,4CACA,4CAEA,MAGA,uFACA,iFACA,yCACA,yCACA,uCACA,uCACA,2DACA,2DAEA,cAEA,IAEA,mDAGA,6CACA,qCACA,iDACA,+CACA,sDACA,+CACA,qDACA,yCACA,oDACA,yCACA,aACA,qCACA,MAEA,IAEA,gBAEA,uBAGA,sDACA,kCACA,yDAGA,oEACA,oEACA,oEACA,2DACA,2DACA,2DAGA,gDACA,gDACA,gDACA,gDAEA,yBACA,uCACA,QAEA,2CAEA,aAEA,iDAEA,MAEA,KAECD,KAAM,OC3SL+J,EAAe,SAAWtF,EAAOE,EAAQqF,GAqB5C,IAAM,IAAIC,KAnBV/L,IAAKqC,KAAMpC,WAEcqC,IAAnBqJ,GAEJhL,QAAQC,MAAO,8CAIhBX,KAAK2B,SAAWiC,gBAAcC,MAAO6H,EAAe/J,UACpD3B,KAAKiB,SAAW,IAAI0C,iBAAgB,CACnChC,SAAU3B,KAAK2B,SACfG,eAAgB4J,EAAe5J,eAC/BF,aAAc8J,EAAe9J,eAI/B5B,KAAK2B,SAAS2E,MAAM/E,MAAQ+E,EAC5BtG,KAAK2B,SAAS6E,OAAOjF,MAAQiF,EAEZqF,EAEXA,EAAOE,eAAgBD,IAAS9L,KAAK2B,SAASoK,eAAgBD,KAElE9L,KAAK2B,SAAUmK,GAAMvK,MAAQsK,EAAQC,IAMvC9L,KAAK+D,OAAS,IAAIhE,IAAKa,eAAgBZ,KAAKiB,WAI7C2K,EAAarL,UAAYF,OAAOC,OAAQD,OAAOkC,OAAQxC,IAAKQ,WAAa,CAExEiC,YAAaoJ,EAEbnL,OAAQ,SAAWgB,EAAUgB,EAAaC,GAExC1C,KAAKiB,SAASU,SAAd,SAAqCJ,MAAQmB,EAAWsB,QAEnDhE,KAAKI,gBAETqB,EAAS2B,gBAAiB,MAC1BpD,KAAK+D,OAAOtD,OAAQgB,KAIpBA,EAAS2B,gBAAiBX,GACrBzC,KAAKG,OAAQsB,EAAStB,QAC5BH,KAAK+D,OAAOtD,OAAQgB,KAMrBjB,QAAS,SAAW8F,EAAOE,GAE1BxG,KAAK2B,SAAS2E,MAAM/E,MAAQ+E,EAC5BtG,KAAK2B,SAAS6E,OAAOjF,MAAQiF","file":"static/js/9.8930f94b.chunk.js","sourcesContent":["import {\n\tOrthographicCamera,\n\tPlaneBufferGeometry,\n\tMesh\n} from \"../../../build/three.module.js\";\n\nfunction Pass() {\n\n\t// if set to true, the pass is processed by the composer\n\tthis.enabled = true;\n\n\t// if set to true, the pass indicates to swap read and write buffer after rendering\n\tthis.needsSwap = true;\n\n\t// if set to true, the pass clears its buffer before rendering\n\tthis.clear = false;\n\n\t// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.\n\tthis.renderToScreen = false;\n\n}\n\nObject.assign( Pass.prototype, {\n\n\tsetSize: function ( /* width, height */ ) {},\n\n\trender: function ( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\n\n\t\tconsole.error( 'THREE.Pass: .render() must be implemented in derived pass.' );\n\n\t}\n\n} );\n\n// Helper for passes that need to fill the viewport with a single quad.\n\nPass.FullScreenQuad = ( function () {\n\n\tvar camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\tvar geometry = new PlaneBufferGeometry( 2, 2 );\n\n\tvar FullScreenQuad = function ( material ) {\n\n\t\tthis._mesh = new Mesh( geometry, material );\n\n\t};\n\n\tObject.defineProperty( FullScreenQuad.prototype, 'material', {\n\n\t\tget: function () {\n\n\t\t\treturn this._mesh.material;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tthis._mesh.material = value;\n\n\t\t}\n\n\t} );\n\n\tObject.assign( FullScreenQuad.prototype, {\n\n\t\tdispose: function () {\n\n\t\t\tthis._mesh.geometry.dispose();\n\n\t\t},\n\n\t\trender: function ( renderer ) {\n\n\t\t\trenderer.render( this._mesh, camera );\n\n\t\t}\n\n\t} );\n\n\treturn FullScreenQuad;\n\n} )();\n\nexport { Pass };\n","/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Full-screen textured quad shader\n */\n\n\n\nvar CopyShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"opacity\": { value: 1.0 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tvUv = uv;\",\n\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" ),\n\n\tfragmentShader: [\n\n\t\t\"uniform float opacity;\",\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tvec4 texel = texture2D( tDiffuse, vUv );\",\n\t\t\"\tgl_FragColor = opacity * texel;\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" )\n\n};\n\nexport { CopyShader };\n","/**\n * @author alteredq / http://alteredqualia.com/\n */\n\n\nimport { Pass } from \"../postprocessing/Pass.js\";\n\nvar RenderPass = function ( scene, camera, overrideMaterial, clearColor, clearAlpha ) {\n\n\tPass.call( this );\n\n\tthis.scene = scene;\n\tthis.camera = camera;\n\n\tthis.overrideMaterial = overrideMaterial;\n\n\tthis.clearColor = clearColor;\n\tthis.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 0;\n\n\tthis.clear = true;\n\tthis.clearDepth = false;\n\tthis.needsSwap = false;\n\n};\n\nRenderPass.prototype = Object.assign( Object.create( Pass.prototype ), {\n\n\tconstructor: RenderPass,\n\n\trender: function ( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\n\n\t\tvar oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\tvar oldClearColor, oldClearAlpha, oldOverrideMaterial;\n\n\t\tif ( this.overrideMaterial !== undefined ) {\n\n\t\t\toldOverrideMaterial = this.scene.overrideMaterial;\n\n\t\t\tthis.scene.overrideMaterial = this.overrideMaterial;\n\n\t\t}\n\n\t\tif ( this.clearColor ) {\n\n\t\t\toldClearColor = renderer.getClearColor().getHex();\n\t\t\toldClearAlpha = renderer.getClearAlpha();\n\n\t\t\trenderer.setClearColor( this.clearColor, this.clearAlpha );\n\n\t\t}\n\n\t\tif ( this.clearDepth ) {\n\n\t\t\trenderer.clearDepth();\n\n\t\t}\n\n\t\trenderer.setRenderTarget( this.renderToScreen ? null : readBuffer );\n\n\t\t// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600\n\t\tif ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\n\t\trenderer.render( this.scene, this.camera );\n\n\t\tif ( this.clearColor ) {\n\n\t\t\trenderer.setClearColor( oldClearColor, oldClearAlpha );\n\n\t\t}\n\n\t\tif ( this.overrideMaterial !== undefined ) {\n\n\t\t\tthis.scene.overrideMaterial = oldOverrideMaterial;\n\n\t\t}\n\n\t\trenderer.autoClear = oldAutoClear;\n\n\t}\n\n} );\n\nexport { RenderPass };\n","/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nimport {\n\tShaderMaterial,\n\tUniformsUtils\n} from \"../../../build/three.module.js\";\nimport { Pass } from \"../postprocessing/Pass.js\";\n\nvar ShaderPass = function ( shader, textureID ) {\n\n\tPass.call( this );\n\n\tthis.textureID = ( textureID !== undefined ) ? textureID : \"tDiffuse\";\n\n\tif ( shader instanceof ShaderMaterial ) {\n\n\t\tthis.uniforms = shader.uniforms;\n\n\t\tthis.material = shader;\n\n\t} else if ( shader ) {\n\n\t\tthis.uniforms = UniformsUtils.clone( shader.uniforms );\n\n\t\tthis.material = new ShaderMaterial( {\n\n\t\t\tdefines: Object.assign( {}, shader.defines ),\n\t\t\tuniforms: this.uniforms,\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader\n\n\t\t} );\n\n\t}\n\n\tthis.fsQuad = new Pass.FullScreenQuad( this.material );\n\n};\n\nShaderPass.prototype = Object.assign( Object.create( Pass.prototype ), {\n\n\tconstructor: ShaderPass,\n\n\trender: function ( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\n\n\t\tif ( this.uniforms[ this.textureID ] ) {\n\n\t\t\tthis.uniforms[ this.textureID ].value = readBuffer.texture;\n\n\t\t}\n\n\t\tthis.fsQuad.material = this.material;\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t} else {\n\n\t\t\trenderer.setRenderTarget( writeBuffer );\n\t\t\t// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600\n\t\t\tif ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t}\n\n\t}\n\n} );\n\nexport { ShaderPass };\n","/**\n * @author alteredq / http://alteredqualia.com/\n */\n\n\nimport { Pass } from \"../postprocessing/Pass.js\";\n\nvar MaskPass = function ( scene, camera ) {\n\n\tPass.call( this );\n\n\tthis.scene = scene;\n\tthis.camera = camera;\n\n\tthis.clear = true;\n\tthis.needsSwap = false;\n\n\tthis.inverse = false;\n\n};\n\nMaskPass.prototype = Object.assign( Object.create( Pass.prototype ), {\n\n\tconstructor: MaskPass,\n\n\trender: function ( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\n\n\t\tvar context = renderer.getContext();\n\t\tvar state = renderer.state;\n\n\t\t// don't update color or depth\n\n\t\tstate.buffers.color.setMask( false );\n\t\tstate.buffers.depth.setMask( false );\n\n\t\t// lock buffers\n\n\t\tstate.buffers.color.setLocked( true );\n\t\tstate.buffers.depth.setLocked( true );\n\n\t\t// set up stencil\n\n\t\tvar writeValue, clearValue;\n\n\t\tif ( this.inverse ) {\n\n\t\t\twriteValue = 0;\n\t\t\tclearValue = 1;\n\n\t\t} else {\n\n\t\t\twriteValue = 1;\n\t\t\tclearValue = 0;\n\n\t\t}\n\n\t\tstate.buffers.stencil.setTest( true );\n\t\tstate.buffers.stencil.setOp( context.REPLACE, context.REPLACE, context.REPLACE );\n\t\tstate.buffers.stencil.setFunc( context.ALWAYS, writeValue, 0xffffffff );\n\t\tstate.buffers.stencil.setClear( clearValue );\n\t\tstate.buffers.stencil.setLocked( true );\n\n\t\t// draw into the stencil buffer\n\n\t\trenderer.setRenderTarget( readBuffer );\n\t\tif ( this.clear ) renderer.clear();\n\t\trenderer.render( this.scene, this.camera );\n\n\t\trenderer.setRenderTarget( writeBuffer );\n\t\tif ( this.clear ) renderer.clear();\n\t\trenderer.render( this.scene, this.camera );\n\n\t\t// unlock color and depth buffer for subsequent rendering\n\n\t\tstate.buffers.color.setLocked( false );\n\t\tstate.buffers.depth.setLocked( false );\n\n\t\t// only render where stencil is set to 1\n\n\t\tstate.buffers.stencil.setLocked( false );\n\t\tstate.buffers.stencil.setFunc( context.EQUAL, 1, 0xffffffff ); // draw if == 1\n\t\tstate.buffers.stencil.setOp( context.KEEP, context.KEEP, context.KEEP );\n\t\tstate.buffers.stencil.setLocked( true );\n\n\t}\n\n} );\n\n\nvar ClearMaskPass = function () {\n\n\tPass.call( this );\n\n\tthis.needsSwap = false;\n\n};\n\nClearMaskPass.prototype = Object.create( Pass.prototype );\n\nObject.assign( ClearMaskPass.prototype, {\n\n\trender: function ( renderer /*, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\n\n\t\trenderer.state.buffers.stencil.setLocked( false );\n\t\trenderer.state.buffers.stencil.setTest( false );\n\n\t}\n\n} );\n\nexport { MaskPass, ClearMaskPass };\n","/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nimport {\n\tClock,\n\tLinearFilter,\n\tMesh,\n\tOrthographicCamera,\n\tPlaneBufferGeometry,\n\tRGBAFormat,\n\tVector2,\n\tWebGLRenderTarget\n} from \"../../../build/three.module.js\";\nimport { CopyShader } from \"../shaders/CopyShader.js\";\nimport { ShaderPass } from \"../postprocessing/ShaderPass.js\";\nimport { MaskPass } from \"../postprocessing/MaskPass.js\";\nimport { ClearMaskPass } from \"../postprocessing/MaskPass.js\";\n\nvar EffectComposer = function ( renderer, renderTarget ) {\n\n\tthis.renderer = renderer;\n\n\tif ( renderTarget === undefined ) {\n\n\t\tvar parameters = {\n\t\t\tminFilter: LinearFilter,\n\t\t\tmagFilter: LinearFilter,\n\t\t\tformat: RGBAFormat,\n\t\t\tstencilBuffer: false\n\t\t};\n\n\t\tvar size = renderer.getSize( new Vector2() );\n\t\tthis._pixelRatio = renderer.getPixelRatio();\n\t\tthis._width = size.width;\n\t\tthis._height = size.height;\n\n\t\trenderTarget = new WebGLRenderTarget( this._width * this._pixelRatio, this._height * this._pixelRatio, parameters );\n\t\trenderTarget.texture.name = 'EffectComposer.rt1';\n\n\t} else {\n\n\t\tthis._pixelRatio = 1;\n\t\tthis._width = renderTarget.width;\n\t\tthis._height = renderTarget.height;\n\n\t}\n\n\tthis.renderTarget1 = renderTarget;\n\tthis.renderTarget2 = renderTarget.clone();\n\tthis.renderTarget2.texture.name = 'EffectComposer.rt2';\n\n\tthis.writeBuffer = this.renderTarget1;\n\tthis.readBuffer = this.renderTarget2;\n\n\tthis.renderToScreen = true;\n\n\tthis.passes = [];\n\n\t// dependencies\n\n\tif ( CopyShader === undefined ) {\n\n\t\tconsole.error( 'THREE.EffectComposer relies on CopyShader' );\n\n\t}\n\n\tif ( ShaderPass === undefined ) {\n\n\t\tconsole.error( 'THREE.EffectComposer relies on ShaderPass' );\n\n\t}\n\n\tthis.copyPass = new ShaderPass( CopyShader );\n\n\tthis.clock = new Clock();\n\n};\n\nObject.assign( EffectComposer.prototype, {\n\n\tswapBuffers: function () {\n\n\t\tvar tmp = this.readBuffer;\n\t\tthis.readBuffer = this.writeBuffer;\n\t\tthis.writeBuffer = tmp;\n\n\t},\n\n\taddPass: function ( pass ) {\n\n\t\tthis.passes.push( pass );\n\t\tpass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );\n\n\t},\n\n\tinsertPass: function ( pass, index ) {\n\n\t\tthis.passes.splice( index, 0, pass );\n\n\t},\n\n\tisLastEnabledPass: function ( passIndex ) {\n\n\t\tfor ( var i = passIndex + 1; i < this.passes.length; i ++ ) {\n\n\t\t\tif ( this.passes[ i ].enabled ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\trender: function ( deltaTime ) {\n\n\t\t// deltaTime value is in seconds\n\n\t\tif ( deltaTime === undefined ) {\n\n\t\t\tdeltaTime = this.clock.getDelta();\n\n\t\t}\n\n\t\tvar currentRenderTarget = this.renderer.getRenderTarget();\n\n\t\tvar maskActive = false;\n\n\t\tvar pass, i, il = this.passes.length;\n\n\t\tfor ( i = 0; i < il; i ++ ) {\n\n\t\t\tpass = this.passes[ i ];\n\n\t\t\tif ( pass.enabled === false ) continue;\n\n\t\t\tpass.renderToScreen = ( this.renderToScreen && this.isLastEnabledPass( i ) );\n\t\t\tpass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive );\n\n\t\t\tif ( pass.needsSwap ) {\n\n\t\t\t\tif ( maskActive ) {\n\n\t\t\t\t\tvar context = this.renderer.getContext();\n\t\t\t\t\tvar stencil = this.renderer.state.buffers.stencil;\n\n\t\t\t\t\t//context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );\n\t\t\t\t\tstencil.setFunc( context.NOTEQUAL, 1, 0xffffffff );\n\n\t\t\t\t\tthis.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime );\n\n\t\t\t\t\t//context.stencilFunc( context.EQUAL, 1, 0xffffffff );\n\t\t\t\t\tstencil.setFunc( context.EQUAL, 1, 0xffffffff );\n\n\t\t\t\t}\n\n\t\t\t\tthis.swapBuffers();\n\n\t\t\t}\n\n\t\t\tif ( MaskPass !== undefined ) {\n\n\t\t\t\tif ( pass instanceof MaskPass ) {\n\n\t\t\t\t\tmaskActive = true;\n\n\t\t\t\t} else if ( pass instanceof ClearMaskPass ) {\n\n\t\t\t\t\tmaskActive = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.renderer.setRenderTarget( currentRenderTarget );\n\n\t},\n\n\treset: function ( renderTarget ) {\n\n\t\tif ( renderTarget === undefined ) {\n\n\t\t\tvar size = this.renderer.getSize( new Vector2() );\n\t\t\tthis._pixelRatio = this.renderer.getPixelRatio();\n\t\t\tthis._width = size.width;\n\t\t\tthis._height = size.height;\n\n\t\t\trenderTarget = this.renderTarget1.clone();\n\t\t\trenderTarget.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );\n\n\t\t}\n\n\t\tthis.renderTarget1.dispose();\n\t\tthis.renderTarget2.dispose();\n\t\tthis.renderTarget1 = renderTarget;\n\t\tthis.renderTarget2 = renderTarget.clone();\n\n\t\tthis.writeBuffer = this.renderTarget1;\n\t\tthis.readBuffer = this.renderTarget2;\n\n\t},\n\n\tsetSize: function ( width, height ) {\n\n\t\tthis._width = width;\n\t\tthis._height = height;\n\n\t\tvar effectiveWidth = this._width * this._pixelRatio;\n\t\tvar effectiveHeight = this._height * this._pixelRatio;\n\n\t\tthis.renderTarget1.setSize( effectiveWidth, effectiveHeight );\n\t\tthis.renderTarget2.setSize( effectiveWidth, effectiveHeight );\n\n\t\tfor ( var i = 0; i < this.passes.length; i ++ ) {\n\n\t\t\tthis.passes[ i ].setSize( effectiveWidth, effectiveHeight );\n\n\t\t}\n\n\t},\n\n\tsetPixelRatio: function ( pixelRatio ) {\n\n\t\tthis._pixelRatio = pixelRatio;\n\n\t\tthis.setSize( this._width, this._height );\n\n\t}\n\n} );\n\n\nvar Pass = function () {\n\n\t// if set to true, the pass is processed by the composer\n\tthis.enabled = true;\n\n\t// if set to true, the pass indicates to swap read and write buffer after rendering\n\tthis.needsSwap = true;\n\n\t// if set to true, the pass clears its buffer before rendering\n\tthis.clear = false;\n\n\t// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.\n\tthis.renderToScreen = false;\n\n};\n\nObject.assign( Pass.prototype, {\n\n\tsetSize: function ( /* width, height */ ) {},\n\n\trender: function ( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\n\n\t\tconsole.error( 'THREE.Pass: .render() must be implemented in derived pass.' );\n\n\t}\n\n} );\n\n// Helper for passes that need to fill the viewport with a single quad.\nPass.FullScreenQuad = ( function () {\n\n\tvar camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\tvar geometry = new PlaneBufferGeometry( 2, 2 );\n\n\tvar FullScreenQuad = function ( material ) {\n\n\t\tthis._mesh = new Mesh( geometry, material );\n\n\t};\n\n\tObject.defineProperty( FullScreenQuad.prototype, 'material', {\n\n\t\tget: function () {\n\n\t\t\treturn this._mesh.material;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tthis._mesh.material = value;\n\n\t\t}\n\n\t} );\n\n\tObject.assign( FullScreenQuad.prototype, {\n\n\t\tdispose: function () {\n\n\t\t\tthis._mesh.geometry.dispose();\n\n\t\t},\n\n\t\trender: function ( renderer ) {\n\n\t\t\trenderer.render( this._mesh, camera );\n\n\t\t}\n\n\t} );\n\n\treturn FullScreenQuad;\n\n} )();\n\nexport { EffectComposer, Pass };\n","/**\n * @author bhouston / http://clara.io/\n *\n * Luminosity\n * http://en.wikipedia.org/wiki/Luminosity\n */\n\nimport {\n\tColor\n} from \"../../../build/three.module.js\";\n\nvar LuminosityHighPassShader = {\n\n\tshaderID: \"luminosityHighPass\",\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"luminosityThreshold\": { value: 1.0 },\n\t\t\"smoothWidth\": { value: 1.0 },\n\t\t\"defaultColor\": { value: new Color( 0x000000 ) },\n\t\t\"defaultOpacity\": { value: 0.0 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tvUv = uv;\",\n\n\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" ),\n\n\tfragmentShader: [\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform vec3 defaultColor;\",\n\t\t\"uniform float defaultOpacity;\",\n\t\t\"uniform float luminosityThreshold;\",\n\t\t\"uniform float smoothWidth;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tvec4 texel = texture2D( tDiffuse, vUv );\",\n\n\t\t\"\tvec3 luma = vec3( 0.299, 0.587, 0.114 );\",\n\n\t\t\"\tfloat v = dot( texel.xyz, luma );\",\n\n\t\t\"\tvec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\",\n\n\t\t\"\tfloat alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\",\n\n\t\t\"\tgl_FragColor = mix( outputColor, texel, alpha );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" )\n\n};\n\nexport { LuminosityHighPassShader };\n","/**\n * @author spidersharma / http://eduperiment.com/\n */\n\nimport {\n\tAdditiveBlending,\n\tColor,\n\tLinearFilter,\n\tMeshBasicMaterial,\n\tRGBAFormat,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector2,\n\tVector3,\n\tWebGLRenderTarget\n} from \"../../../build/three.module.js\";\nimport { Pass } from \"../postprocessing/Pass.js\";\nimport { CopyShader } from \"../shaders/CopyShader.js\";\nimport { LuminosityHighPassShader } from \"../shaders/LuminosityHighPassShader.js\";\n\n/**\n * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a\n * mip map chain of bloom textures and blurs them with different radii. Because\n * of the weighted combination of mips, and because larger blurs are done on\n * higher mips, this effect provides good quality and performance.\n *\n * Reference:\n * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/\n */\nvar UnrealBloomPass = function ( resolution, strength, radius, threshold ) {\n\n\tPass.call( this );\n\n\tthis.strength = ( strength !== undefined ) ? strength : 1;\n\tthis.radius = radius;\n\tthis.threshold = threshold;\n\tthis.resolution = ( resolution !== undefined ) ? new Vector2( resolution.x, resolution.y ) : new Vector2( 256, 256 );\n\n\t// create color only once here, reuse it later inside the render function\n\tthis.clearColor = new Color( 0, 0, 0 );\n\n\t// render targets\n\tvar pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };\n\tthis.renderTargetsHorizontal = [];\n\tthis.renderTargetsVertical = [];\n\tthis.nMips = 5;\n\tvar resx = Math.round( this.resolution.x / 2 );\n\tvar resy = Math.round( this.resolution.y / 2 );\n\n\tthis.renderTargetBright = new WebGLRenderTarget( resx, resy, pars );\n\tthis.renderTargetBright.texture.name = \"UnrealBloomPass.bright\";\n\tthis.renderTargetBright.texture.generateMipmaps = false;\n\n\tfor ( var i = 0; i < this.nMips; i ++ ) {\n\n\t\tvar renderTargetHorizonal = new WebGLRenderTarget( resx, resy, pars );\n\n\t\trenderTargetHorizonal.texture.name = \"UnrealBloomPass.h\" + i;\n\t\trenderTargetHorizonal.texture.generateMipmaps = false;\n\n\t\tthis.renderTargetsHorizontal.push( renderTargetHorizonal );\n\n\t\tvar renderTargetVertical = new WebGLRenderTarget( resx, resy, pars );\n\n\t\trenderTargetVertical.texture.name = \"UnrealBloomPass.v\" + i;\n\t\trenderTargetVertical.texture.generateMipmaps = false;\n\n\t\tthis.renderTargetsVertical.push( renderTargetVertical );\n\n\t\tresx = Math.round( resx / 2 );\n\n\t\tresy = Math.round( resy / 2 );\n\n\t}\n\n\t// luminosity high pass material\n\n\tif ( LuminosityHighPassShader === undefined )\n\t\tconsole.error( \"UnrealBloomPass relies on LuminosityHighPassShader\" );\n\n\tvar highPassShader = LuminosityHighPassShader;\n\tthis.highPassUniforms = UniformsUtils.clone( highPassShader.uniforms );\n\n\tthis.highPassUniforms[ \"luminosityThreshold\" ].value = threshold;\n\tthis.highPassUniforms[ \"smoothWidth\" ].value = 0.01;\n\n\tthis.materialHighPassFilter = new ShaderMaterial( {\n\t\tuniforms: this.highPassUniforms,\n\t\tvertexShader: highPassShader.vertexShader,\n\t\tfragmentShader: highPassShader.fragmentShader,\n\t\tdefines: {}\n\t} );\n\n\t// Gaussian Blur Materials\n\tthis.separableBlurMaterials = [];\n\tvar kernelSizeArray = [ 3, 5, 7, 9, 11 ];\n\tvar resx = Math.round( this.resolution.x / 2 );\n\tvar resy = Math.round( this.resolution.y / 2 );\n\n\tfor ( var i = 0; i < this.nMips; i ++ ) {\n\n\t\tthis.separableBlurMaterials.push( this.getSeperableBlurMaterial( kernelSizeArray[ i ] ) );\n\n\t\tthis.separableBlurMaterials[ i ].uniforms[ \"texSize\" ].value = new Vector2( resx, resy );\n\n\t\tresx = Math.round( resx / 2 );\n\n\t\tresy = Math.round( resy / 2 );\n\n\t}\n\n\t// Composite material\n\tthis.compositeMaterial = this.getCompositeMaterial( this.nMips );\n\tthis.compositeMaterial.uniforms[ \"blurTexture1\" ].value = this.renderTargetsVertical[ 0 ].texture;\n\tthis.compositeMaterial.uniforms[ \"blurTexture2\" ].value = this.renderTargetsVertical[ 1 ].texture;\n\tthis.compositeMaterial.uniforms[ \"blurTexture3\" ].value = this.renderTargetsVertical[ 2 ].texture;\n\tthis.compositeMaterial.uniforms[ \"blurTexture4\" ].value = this.renderTargetsVertical[ 3 ].texture;\n\tthis.compositeMaterial.uniforms[ \"blurTexture5\" ].value = this.renderTargetsVertical[ 4 ].texture;\n\tthis.compositeMaterial.uniforms[ \"bloomStrength\" ].value = strength;\n\tthis.compositeMaterial.uniforms[ \"bloomRadius\" ].value = 0.1;\n\tthis.compositeMaterial.needsUpdate = true;\n\n\tvar bloomFactors = [ 1.0, 0.8, 0.6, 0.4, 0.2 ];\n\tthis.compositeMaterial.uniforms[ \"bloomFactors\" ].value = bloomFactors;\n\tthis.bloomTintColors = [ new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ),\n\t\t\t\t\t\t\t new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ) ];\n\tthis.compositeMaterial.uniforms[ \"bloomTintColors\" ].value = this.bloomTintColors;\n\n\t// copy material\n\tif ( CopyShader === undefined ) {\n\n\t\tconsole.error( \"UnrealBloomPass relies on CopyShader\" );\n\n\t}\n\n\tvar copyShader = CopyShader;\n\n\tthis.copyUniforms = UniformsUtils.clone( copyShader.uniforms );\n\tthis.copyUniforms[ \"opacity\" ].value = 1.0;\n\n\tthis.materialCopy = new ShaderMaterial( {\n\t\tuniforms: this.copyUniforms,\n\t\tvertexShader: copyShader.vertexShader,\n\t\tfragmentShader: copyShader.fragmentShader,\n\t\tblending: AdditiveBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false,\n\t\ttransparent: true\n\t} );\n\n\tthis.enabled = true;\n\tthis.needsSwap = false;\n\n\tthis.oldClearColor = new Color();\n\tthis.oldClearAlpha = 1;\n\n\tthis.basic = new MeshBasicMaterial();\n\n\tthis.fsQuad = new Pass.FullScreenQuad( null );\n\n};\n\nUnrealBloomPass.prototype = Object.assign( Object.create( Pass.prototype ), {\n\n\tconstructor: UnrealBloomPass,\n\n\tdispose: function () {\n\n\t\tfor ( var i = 0; i < this.renderTargetsHorizontal.length; i ++ ) {\n\n\t\t\tthis.renderTargetsHorizontal[ i ].dispose();\n\n\t\t}\n\n\t\tfor ( var i = 0; i < this.renderTargetsVertical.length; i ++ ) {\n\n\t\t\tthis.renderTargetsVertical[ i ].dispose();\n\n\t\t}\n\n\t\tthis.renderTargetBright.dispose();\n\n\t},\n\n\tsetSize: function ( width, height ) {\n\n\t\tvar resx = Math.round( width / 2 );\n\t\tvar resy = Math.round( height / 2 );\n\n\t\tthis.renderTargetBright.setSize( resx, resy );\n\n\t\tfor ( var i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tthis.renderTargetsHorizontal[ i ].setSize( resx, resy );\n\t\t\tthis.renderTargetsVertical[ i ].setSize( resx, resy );\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ \"texSize\" ].value = new Vector2( resx, resy );\n\n\t\t\tresx = Math.round( resx / 2 );\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t},\n\n\trender: function ( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {\n\n\t\tthis.oldClearColor.copy( renderer.getClearColor() );\n\t\tthis.oldClearAlpha = renderer.getClearAlpha();\n\t\tvar oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\trenderer.setClearColor( this.clearColor, 0 );\n\n\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( false );\n\n\t\t// Render input to screen\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\tthis.fsQuad.material = this.basic;\n\t\t\tthis.basic.map = readBuffer.texture;\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t}\n\n\t\t// 1. Extract Bright Areas\n\n\t\tthis.highPassUniforms[ \"tDiffuse\" ].value = readBuffer.texture;\n\t\tthis.highPassUniforms[ \"luminosityThreshold\" ].value = this.threshold;\n\t\tthis.fsQuad.material = this.materialHighPassFilter;\n\n\t\trenderer.setRenderTarget( this.renderTargetBright );\n\t\trenderer.clear();\n\t\tthis.fsQuad.render( renderer );\n\n\t\t// 2. Blur All the mips progressively\n\n\t\tvar inputRenderTarget = this.renderTargetBright;\n\n\t\tfor ( var i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tthis.fsQuad.material = this.separableBlurMaterials[ i ];\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ \"colorTexture\" ].value = inputRenderTarget.texture;\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ \"direction\" ].value = UnrealBloomPass.BlurDirectionX;\n\t\t\trenderer.setRenderTarget( this.renderTargetsHorizontal[ i ] );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ \"colorTexture\" ].value = this.renderTargetsHorizontal[ i ].texture;\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ \"direction\" ].value = UnrealBloomPass.BlurDirectionY;\n\t\t\trenderer.setRenderTarget( this.renderTargetsVertical[ i ] );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\tinputRenderTarget = this.renderTargetsVertical[ i ];\n\n\t\t}\n\n\t\t// Composite All the mips\n\n\t\tthis.fsQuad.material = this.compositeMaterial;\n\t\tthis.compositeMaterial.uniforms[ \"bloomStrength\" ].value = this.strength;\n\t\tthis.compositeMaterial.uniforms[ \"bloomRadius\" ].value = this.radius;\n\t\tthis.compositeMaterial.uniforms[ \"bloomTintColors\" ].value = this.bloomTintColors;\n\n\t\trenderer.setRenderTarget( this.renderTargetsHorizontal[ 0 ] );\n\t\trenderer.clear();\n\t\tthis.fsQuad.render( renderer );\n\n\t\t// Blend it additively over the input texture\n\n\t\tthis.fsQuad.material = this.materialCopy;\n\t\tthis.copyUniforms[ \"tDiffuse\" ].value = this.renderTargetsHorizontal[ 0 ].texture;\n\n\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( true );\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t} else {\n\n\t\t\trenderer.setRenderTarget( readBuffer );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t}\n\n\t\t// Restore renderer settings\n\n\t\trenderer.setClearColor( this.oldClearColor, this.oldClearAlpha );\n\t\trenderer.autoClear = oldAutoClear;\n\n\t},\n\n\tgetSeperableBlurMaterial: function ( kernelRadius ) {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tdefines: {\n\t\t\t\t\"KERNEL_RADIUS\": kernelRadius,\n\t\t\t\t\"SIGMA\": kernelRadius\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t\"colorTexture\": { value: null },\n\t\t\t\t\"texSize\": { value: new Vector2( 0.5, 0.5 ) },\n\t\t\t\t\"direction\": { value: new Vector2( 0.5, 0.5 ) }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t\"varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}\",\n\n\t\t\tfragmentShader:\n\t\t\t\t\"#include <common>\\\n\t\t\t\tvarying vec2 vUv;\\n\\\n\t\t\t\tuniform sampler2D colorTexture;\\n\\\n\t\t\t\tuniform vec2 texSize;\\\n\t\t\t\tuniform vec2 direction;\\\n\t\t\t\t\\\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\\\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\\n\t\t\t\t}\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\\\n\t\t\t\t\tfloat fSigma = float(SIGMA);\\\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\\\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\\\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\\\n\t\t\t\t\t\tfloat x = float(i);\\\n\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\\\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\\\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\\\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\\\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\\\n\t\t\t\t\t\tweightSum += 2.0 * w;\\\n\t\t\t\t\t}\\\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\\n\\\n\t\t\t\t}\"\n\t\t} );\n\n\t},\n\n\tgetCompositeMaterial: function ( nMips ) {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tdefines: {\n\t\t\t\t\"NUM_MIPS\": nMips\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t\"blurTexture1\": { value: null },\n\t\t\t\t\"blurTexture2\": { value: null },\n\t\t\t\t\"blurTexture3\": { value: null },\n\t\t\t\t\"blurTexture4\": { value: null },\n\t\t\t\t\"blurTexture5\": { value: null },\n\t\t\t\t\"dirtTexture\": { value: null },\n\t\t\t\t\"bloomStrength\": { value: 1.0 },\n\t\t\t\t\"bloomFactors\": { value: null },\n\t\t\t\t\"bloomTintColors\": { value: null },\n\t\t\t\t\"bloomRadius\": { value: 0.0 }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t\"varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}\",\n\n\t\t\tfragmentShader:\n\t\t\t\t\"varying vec2 vUv;\\\n\t\t\t\tuniform sampler2D blurTexture1;\\\n\t\t\t\tuniform sampler2D blurTexture2;\\\n\t\t\t\tuniform sampler2D blurTexture3;\\\n\t\t\t\tuniform sampler2D blurTexture4;\\\n\t\t\t\tuniform sampler2D blurTexture5;\\\n\t\t\t\tuniform sampler2D dirtTexture;\\\n\t\t\t\tuniform float bloomStrength;\\\n\t\t\t\tuniform float bloomRadius;\\\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\\\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\\\n\t\t\t\t\\\n\t\t\t\tfloat lerpBloomFactor(const in float factor) { \\\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\\\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\\\n\t\t\t\t}\\\n\t\t\t\t\\\n\t\t\t\tvoid main() {\\\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\\\n\t\t\t\t}\"\n\t\t} );\n\n\t}\n\n} );\n\nUnrealBloomPass.BlurDirectionX = new Vector2( 1.0, 0.0 );\nUnrealBloomPass.BlurDirectionY = new Vector2( 0.0, 1.0 );\n\nexport { UnrealBloomPass };\n","/**\n * @author meatbags / xavierburrow.com, github/meatbags\n *\n * RGB Halftone shader for three.js.\n *\tNOTE:\n * \t\tShape (1 = Dot, 2 = Ellipse, 3 = Line, 4 = Square)\n *\t\tBlending Mode (1 = Linear, 2 = Multiply, 3 = Add, 4 = Lighter, 5 = Darker)\n */\n\n\n\nvar HalftoneShader = {\n\n\tuniforms: {\n\t\t\"tDiffuse\": { value: null },\n\t\t\"shape\": { value: 1 },\n\t\t\"radius\": { value: 4 },\n\t\t\"rotateR\": { value: Math.PI / 12 * 1 },\n\t\t\"rotateG\": { value: Math.PI / 12 * 2 },\n\t\t\"rotateB\": { value: Math.PI / 12 * 3 },\n\t\t\"scatter\": { value: 0 },\n\t\t\"width\": { value: 1 },\n\t\t\"height\": { value: 1 },\n\t\t\"blending\": { value: 1 },\n\t\t\"blendingMode\": { value: 1 },\n\t\t\"greyscale\": { value: false },\n\t\t\"disable\": { value: false }\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUV;\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tvUV = uv;\",\n\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" ),\n\n\tfragmentShader: [\n\n\t\t\"#define SQRT2_MINUS_ONE 0.41421356\",\n\t\t\"#define SQRT2_HALF_MINUS_ONE 0.20710678\",\n\t\t\"#define PI2 6.28318531\",\n\t\t\"#define SHAPE_DOT 1\",\n\t\t\"#define SHAPE_ELLIPSE 2\",\n\t\t\"#define SHAPE_LINE 3\",\n\t\t\"#define SHAPE_SQUARE 4\",\n\t\t\"#define BLENDING_LINEAR 1\",\n\t\t\"#define BLENDING_MULTIPLY 2\",\n\t\t\"#define BLENDING_ADD 3\",\n\t\t\"#define BLENDING_LIGHTER 4\",\n\t\t\"#define BLENDING_DARKER 5\",\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform float radius;\",\n\t\t\"uniform float rotateR;\",\n\t\t\"uniform float rotateG;\",\n\t\t\"uniform float rotateB;\",\n\t\t\"uniform float scatter;\",\n\t\t\"uniform float width;\",\n\t\t\"uniform float height;\",\n\t\t\"uniform int shape;\",\n\t\t\"uniform bool disable;\",\n\t\t\"uniform float blending;\",\n\t\t\"uniform int blendingMode;\",\n\t\t\"varying vec2 vUV;\",\n\t\t\"uniform bool greyscale;\",\n\t\t\"const int samples = 8;\",\n\n\t\t\"float blend( float a, float b, float t ) {\",\n\n\t\t// linear blend\n\t\t\"\treturn a * ( 1.0 - t ) + b * t;\",\n\n\t\t\"}\",\n\n\t\t\"float hypot( float x, float y ) {\",\n\n\t\t// vector magnitude\n\t\t\"\treturn sqrt( x * x + y * y );\",\n\n\t\t\"}\",\n\n\t\t\"float rand( vec2 seed ){\",\n\n\t\t// get pseudo-random number\n\t    \"return fract( sin( dot( seed.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\",\n\n\t\t\"}\",\n\n\t\t\"float distanceToDotRadius( float channel, vec2 coord, vec2 normal, vec2 p, float angle, float rad_max ) {\",\n\n\t\t// apply shape-specific transforms\n\t\t\"\tfloat dist = hypot( coord.x - p.x, coord.y - p.y );\",\n\t\t\"\tfloat rad = channel;\",\n\n\t\t\"\tif ( shape == SHAPE_DOT ) {\",\n\n\t\t\"\t\trad = pow( abs( rad ), 1.125 ) * rad_max;\",\n\n\t\t\"\t} else if ( shape == SHAPE_ELLIPSE ) {\",\n\n\t\t\"\t\trad = pow( abs( rad ), 1.125 ) * rad_max;\",\n\n\t\t\"\t\tif ( dist != 0.0 ) {\",\n\t\t\"\t\t\tfloat dot_p = abs( ( p.x - coord.x ) / dist * normal.x + ( p.y - coord.y ) / dist * normal.y );\",\n\t\t\"\t\t\tdist = ( dist * ( 1.0 - SQRT2_HALF_MINUS_ONE ) ) + dot_p * dist * SQRT2_MINUS_ONE;\",\n\t\t\"\t\t}\",\n\n\t\t\"\t} else if ( shape == SHAPE_LINE ) {\",\n\n\t\t\"\t\trad = pow( abs( rad ), 1.5) * rad_max;\",\n\t\t\"\t\tfloat dot_p = ( p.x - coord.x ) * normal.x + ( p.y - coord.y ) * normal.y;\",\n\t\t\"\t\tdist = hypot( normal.x * dot_p, normal.y * dot_p );\",\n\n\t\t\"\t} else if ( shape == SHAPE_SQUARE ) {\",\n\n\t\t\"\t\tfloat theta = atan( p.y - coord.y, p.x - coord.x ) - angle;\",\n\t\t\"\t\tfloat sin_t = abs( sin( theta ) );\",\n\t\t\"\t\tfloat cos_t = abs( cos( theta ) );\",\n\t\t\"\t\trad = pow( abs( rad ), 1.4 );\",\n\t\t\"\t\trad = rad_max * ( rad + ( ( sin_t > cos_t ) ? rad - sin_t * rad : rad - cos_t * rad ) );\",\n\n\t\t\"\t}\",\n\n\t\t\"\treturn rad - dist;\",\n\n\t\t\"}\",\n\n\t\t\"struct Cell {\",\n\n\t\t// grid sample positions\n\t\t\"\tvec2 normal;\",\n\t\t\"\tvec2 p1;\",\n\t\t\"\tvec2 p2;\",\n\t\t\"\tvec2 p3;\",\n\t\t\"\tvec2 p4;\",\n\t\t\"\tfloat samp2;\",\n\t\t\"\tfloat samp1;\",\n\t\t\"\tfloat samp3;\",\n\t\t\"\tfloat samp4;\",\n\n\t\t\"};\",\n\n\t\t\"vec4 getSample( vec2 point ) {\",\n\n\t\t// multi-sampled point\n\t\t\"\tvec4 tex = texture2D( tDiffuse, vec2( point.x / width, point.y / height ) );\",\n\t\t\"\tfloat base = rand( vec2( floor( point.x ), floor( point.y ) ) ) * PI2;\",\n\t\t\"\tfloat step = PI2 / float( samples );\",\n\t\t\"\tfloat dist = radius * 0.66;\",\n\n\t\t\"\tfor ( int i = 0; i < samples; ++i ) {\",\n\n\t\t\"\t\tfloat r = base + step * float( i );\",\n\t\t\"\t\tvec2 coord = point + vec2( cos( r ) * dist, sin( r ) * dist );\",\n\t\t\"\t\ttex += texture2D( tDiffuse, vec2( coord.x / width, coord.y / height ) );\",\n\n\t\t\"\t}\",\n\n\t\t\"\ttex /= float( samples ) + 1.0;\",\n\t\t\"\treturn tex;\",\n\n\t\t\"}\",\n\n\t\t\"float getDotColour( Cell c, vec2 p, int channel, float angle, float aa ) {\",\n\n\t\t// get colour for given point\n\t\t\"\tfloat dist_c_1, dist_c_2, dist_c_3, dist_c_4, res;\",\n\n\t\t\"\tif ( channel == 0 ) {\",\n\n\t\t\"\t\tc.samp1 = getSample( c.p1 ).r;\",\n\t\t\"\t\tc.samp2 = getSample( c.p2 ).r;\",\n\t\t\"\t\tc.samp3 = getSample( c.p3 ).r;\",\n\t\t\"\t\tc.samp4 = getSample( c.p4 ).r;\",\n\n\t\t\"\t} else if (channel == 1) {\",\n\n\t\t\"\t\tc.samp1 = getSample( c.p1 ).g;\",\n\t\t\"\t\tc.samp2 = getSample( c.p2 ).g;\",\n\t\t\"\t\tc.samp3 = getSample( c.p3 ).g;\",\n\t\t\"\t\tc.samp4 = getSample( c.p4 ).g;\",\n\n\t\t\"\t} else {\",\n\n\t\t\"\t\tc.samp1 = getSample( c.p1 ).b;\",\n\t\t\"\t\tc.samp3 = getSample( c.p3 ).b;\",\n\t\t\"\t\tc.samp2 = getSample( c.p2 ).b;\",\n\t\t\"\t\tc.samp4 = getSample( c.p4 ).b;\",\n\n\t\t\"\t}\",\n\n\t\t\"\tdist_c_1 = distanceToDotRadius( c.samp1, c.p1, c.normal, p, angle, radius );\",\n\t\t\"\tdist_c_2 = distanceToDotRadius( c.samp2, c.p2, c.normal, p, angle, radius );\",\n\t\t\"\tdist_c_3 = distanceToDotRadius( c.samp3, c.p3, c.normal, p, angle, radius );\",\n\t\t\"\tdist_c_4 = distanceToDotRadius( c.samp4, c.p4, c.normal, p, angle, radius );\",\n\t\t\"\tres = ( dist_c_1 > 0.0 ) ? clamp( dist_c_1 / aa, 0.0, 1.0 ) : 0.0;\",\n\t\t\"\tres += ( dist_c_2 > 0.0 ) ? clamp( dist_c_2 / aa, 0.0, 1.0 ) : 0.0;\",\n\t\t\"\tres += ( dist_c_3 > 0.0 ) ? clamp( dist_c_3 / aa, 0.0, 1.0 ) : 0.0;\",\n\t\t\"\tres += ( dist_c_4 > 0.0 ) ? clamp( dist_c_4 / aa, 0.0, 1.0 ) : 0.0;\",\n\t\t\"\tres = clamp( res, 0.0, 1.0 );\",\n\n\t\t\"\treturn res;\",\n\n\t\t\"}\",\n\n\t\t\"Cell getReferenceCell( vec2 p, vec2 origin, float grid_angle, float step ) {\",\n\n\t\t// get containing cell\n\t\t\"\tCell c;\",\n\n\t\t// calc grid\n\t\t\"\tvec2 n = vec2( cos( grid_angle ), sin( grid_angle ) );\",\n\t\t\"\tfloat threshold = step * 0.5;\",\n\t\t\"\tfloat dot_normal = n.x * ( p.x - origin.x ) + n.y * ( p.y - origin.y );\",\n\t\t\"\tfloat dot_line = -n.y * ( p.x - origin.x ) + n.x * ( p.y - origin.y );\",\n\t\t\"\tvec2 offset = vec2( n.x * dot_normal, n.y * dot_normal );\",\n\t\t\"\tfloat offset_normal = mod( hypot( offset.x, offset.y ), step );\",\n\t\t\"\tfloat normal_dir = ( dot_normal < 0.0 ) ? 1.0 : -1.0;\",\n\t\t\"\tfloat normal_scale = ( ( offset_normal < threshold ) ? -offset_normal : step - offset_normal ) * normal_dir;\",\n\t\t\"\tfloat offset_line = mod( hypot( ( p.x - offset.x ) - origin.x, ( p.y - offset.y ) - origin.y ), step );\",\n\t\t\"\tfloat line_dir = ( dot_line < 0.0 ) ? 1.0 : -1.0;\",\n\t\t\"\tfloat line_scale = ( ( offset_line < threshold ) ? -offset_line : step - offset_line ) * line_dir;\",\n\n\t\t// get closest corner\n\t\t\"\tc.normal = n;\",\n\t\t\"\tc.p1.x = p.x - n.x * normal_scale + n.y * line_scale;\",\n\t\t\"\tc.p1.y = p.y - n.y * normal_scale - n.x * line_scale;\",\n\n\t\t// scatter\n\t\t\"\tif ( scatter != 0.0 ) {\",\n\n\t\t\"\t\tfloat off_mag = scatter * threshold * 0.5;\",\n\t\t\"\t\tfloat off_angle = rand( vec2( floor( c.p1.x ), floor( c.p1.y ) ) ) * PI2;\",\n\t\t\"\t\tc.p1.x += cos( off_angle ) * off_mag;\",\n\t\t\"\t\tc.p1.y += sin( off_angle ) * off_mag;\",\n\n\t\t\"\t}\",\n\n\t\t// find corners\n\t\t\"\tfloat normal_step = normal_dir * ( ( offset_normal < threshold ) ? step : -step );\",\n\t\t\"\tfloat line_step = line_dir * ( ( offset_line < threshold ) ? step : -step );\",\n\t\t\"\tc.p2.x = c.p1.x - n.x * normal_step;\",\n\t\t\"\tc.p2.y = c.p1.y - n.y * normal_step;\",\n\t\t\"\tc.p3.x = c.p1.x + n.y * line_step;\",\n\t\t\"\tc.p3.y = c.p1.y - n.x * line_step;\",\n\t\t\"\tc.p4.x = c.p1.x - n.x * normal_step + n.y * line_step;\",\n\t\t\"\tc.p4.y = c.p1.y - n.y * normal_step - n.x * line_step;\",\n\n\t\t\"\treturn c;\",\n\n\t\t\"}\",\n\n\t\t\"float blendColour( float a, float b, float t ) {\",\n\n\t\t// blend colours\n\t\t\"\tif ( blendingMode == BLENDING_LINEAR ) {\",\n\t\t\"\t\treturn blend( a, b, 1.0 - t );\",\n\t\t\"\t} else if ( blendingMode == BLENDING_ADD ) {\",\n\t\t\"\t\treturn blend( a, min( 1.0, a + b ), t );\",\n\t\t\"\t} else if ( blendingMode == BLENDING_MULTIPLY ) {\",\n\t\t\"\t\treturn blend( a, max( 0.0, a * b ), t );\",\n\t\t\"\t} else if ( blendingMode == BLENDING_LIGHTER ) {\",\n\t\t\"\t\treturn blend( a, max( a, b ), t );\",\n\t\t\"\t} else if ( blendingMode == BLENDING_DARKER ) {\",\n\t\t\"\t\treturn blend( a, min( a, b ), t );\",\n\t\t\"\t} else {\",\n\t\t\"\t\treturn blend( a, b, 1.0 - t );\",\n\t\t\"\t}\",\n\n\t\t\"}\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tif ( ! disable ) {\",\n\n\t\t// setup\n\t\t\"\t\tvec2 p = vec2( vUV.x * width, vUV.y * height );\",\n\t\t\"\t\tvec2 origin = vec2( 0, 0 );\",\n\t\t\"\t\tfloat aa = ( radius < 2.5 ) ? radius * 0.5 : 1.25;\",\n\n\t\t// get channel samples\n\t\t\"\t\tCell cell_r = getReferenceCell( p, origin, rotateR, radius );\",\n\t\t\"\t\tCell cell_g = getReferenceCell( p, origin, rotateG, radius );\",\n\t\t\"\t\tCell cell_b = getReferenceCell( p, origin, rotateB, radius );\",\n\t\t\"\t\tfloat r = getDotColour( cell_r, p, 0, rotateR, aa );\",\n\t\t\"\t\tfloat g = getDotColour( cell_g, p, 1, rotateG, aa );\",\n\t\t\"\t\tfloat b = getDotColour( cell_b, p, 2, rotateB, aa );\",\n\n\t\t// blend with original\n\t\t\"\t\tvec4 colour = texture2D( tDiffuse, vUV );\",\n\t\t\"\t\tr = blendColour( r, colour.r, blending );\",\n\t\t\"\t\tg = blendColour( g, colour.g, blending );\",\n\t\t\"\t\tb = blendColour( b, colour.b, blending );\",\n\n\t\t\"\t\tif ( greyscale ) {\",\n\t\t\"\t\t\tr = g = b = (r + b + g) / 3.0;\",\n\t\t\"\t\t}\",\n\n\t\t\"\t\tgl_FragColor = vec4( r, g, b, 1.0 );\",\n\n\t\t\"\t} else {\",\n\n\t\t\"\t\tgl_FragColor = texture2D( tDiffuse, vUV );\",\n\n\t\t\"\t}\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" )\n\n};\n\nexport { HalftoneShader };\n","/**\n * @author meatbags / xavierburrow.com, github/meatbags\n *\n * RGB Halftone pass for three.js effects composer. Requires HalftoneShader.\n *\n */\n\nimport {\n\tShaderMaterial,\n\tUniformsUtils\n} from \"../../../build/three.module.js\";\nimport { Pass } from \"../postprocessing/Pass.js\";\nimport { HalftoneShader } from \"../shaders/HalftoneShader.js\";\n\nvar HalftonePass = function ( width, height, params ) {\n\n\tPass.call( this );\n\n \tif ( HalftoneShader === undefined ) {\n\n \t\tconsole.error( 'THREE.HalftonePass requires HalftoneShader' );\n\n \t}\n\n \tthis.uniforms = UniformsUtils.clone( HalftoneShader.uniforms );\n \tthis.material = new ShaderMaterial( {\n \t\tuniforms: this.uniforms,\n \t\tfragmentShader: HalftoneShader.fragmentShader,\n \t\tvertexShader: HalftoneShader.vertexShader\n \t} );\n\n\t// set params\n\tthis.uniforms.width.value = width;\n\tthis.uniforms.height.value = height;\n\n\tfor ( var key in params ) {\n\n\t\tif ( params.hasOwnProperty( key ) && this.uniforms.hasOwnProperty( key ) ) {\n\n\t\t\tthis.uniforms[ key ].value = params[ key ];\n\n\t\t}\n\n\t}\n\n\tthis.fsQuad = new Pass.FullScreenQuad( this.material );\n\n};\n\nHalftonePass.prototype = Object.assign( Object.create( Pass.prototype ), {\n\n\tconstructor: HalftonePass,\n\n\trender: function ( renderer, writeBuffer, readBuffer/*, deltaTime, maskActive*/ ) {\n\n \t\tthis.material.uniforms[ \"tDiffuse\" ].value = readBuffer.texture;\n\n \t\tif ( this.renderToScreen ) {\n\n \t\t\trenderer.setRenderTarget( null );\n \t\t\tthis.fsQuad.render( renderer );\n\n\t\t} else {\n\n \t\t\trenderer.setRenderTarget( writeBuffer );\n \t\t\tif ( this.clear ) renderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t}\n\n \t},\n\n \tsetSize: function ( width, height ) {\n\n \t\tthis.uniforms.width.value = width;\n \t\tthis.uniforms.height.value = height;\n\n \t}\n} );\n\nexport { HalftonePass };\n"],"sourceRoot":""}